<%= @question.errors.full_messages.join(", ") %>
<%# form_for takes in an ActiveRecord object as a first argument. Then it looks at the object. If the object is not persisted (not yet saved to the database), the form will automatically use POST for its method. It will also automatically use questions_path as its action (convention is that the 'questions_path' will submit to the 'create' action). If persisted, then Rails assumes that we want to UPDATE it.  %>
<%= form_for @question do |f| %>
<%# we call 'f' the form object - will prepopulate values and will be able to access error messages as well. %>
<div>
  <%= f.label :title %>
  <%= f.text_field :title %>
  <%# with `f` we don't need to use _tags %>
</div>
<div>
  <%= f.label :body %>
  <%= f.text_area :body %>
</div>
<div>
  <%= f.label :category_id %>
  <%= f.collection_select(:category_id, Category.order(:name), :id, :name) %>
</div>
<div>
  <%= f.submit %>
</div>
<% end %>

<%# if @question IS persisted, then the form will use PATCH by adding a hidden field with name _method and value PATCH. The action URL will be question_path(@question) %>

<%# we call 'f' the form object - will prepopulate values and will be able to access error messages as well. %>

<%# to use f.collection_selectionw e %>
<%# collection_select(:post, :author_id, Author.all, :id, :name_with_initial, prompt: true)
 %>
